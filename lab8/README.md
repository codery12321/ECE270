# Pre-Lab Submission 8

This will be your last breadboard lab, and the largest one in terms of circuit construction. Do not put this lab off until the last minute.

This lab is about implementing an arbitrary sequential state machine. The state machine you will build has three bits of state. This will be represented by three flip-flops that share the same clock. A reset signal will be connected to either the asynchronous preset or clear input of each flip-flop to force the state of the system to a particular three-bit value. For the actual lab experiment, you will use the following components:

(2) 74HC74 dual D-type flip-flops with asynchronous preset and clear
(2) 74HC151 8-to-1 multiplexers
(1) 74HC138 3-to-8 decoder with active-low outputs
(1) 74HC10 triple 3-input NAND gate
(1) 74HC08 quad 2-input AND gate
(1) 74HC14 hex Schmitt-trigger inverter

For the prelab, you will model the work with Verilog.

**Implementing the next-state logic**

Recall [the diagram of a Moore-model state Machine](moore.png).


For this lab, you will implement all three portions of the Moore model - the next-state logic, state machine, and output logic. The next-state will depend only on the three bits of the current state. An easy way to implement a three-variable logic function is to use a 3-to-8 decoder. When the decoder has active-low outputs, the inverted minterms can be summed with NAND gates. This is very similar to what you did for lab 5 when you implemented eight unique logic functions.

Implement these functions in the top module of your design as follows:
- Represent the state with a three-bit logic bus named 'q'.
- Represent the "next-state" with a three-bit logic bus named 'next_q'.
- Represent the output logic with a 2 bit logic bus named 'f'.
- Rather than using discrete structural flip-flops, use an always_ff block to update the 'q' bus as follows:
  - Use pb[1] as an asynchronous reset signal. It should set the state of the three flip-flops to the value specified below. As long as pb[1] is asserted, the state of the flip-flops will retain this value regardless of the actions of the clock signal.
  - Use pb[0] as a clock signal. As long as pb[1] is not asserted, it should set the 'q' logic bus to 'next_q'.
- Add the SystemVerilog model of the 74HC138 to your design. Create one instance of it, connect its 'a' inputs to the state 'q', and wire its 'e' enable pins to allow exactly one of its outputs to be active all the time. Connect an 8-bit logic bus named 'p' (product terms) to the 'y' output of the decoder.
- Add the SystemVerilog model of the 74HC151 to your design. Create two instances of it. For the first instance, connect the 'i' input to the value represented by your first lookup table, the 's' input to 'q', and the 'z' output to 'f[0]'. For the second instance, connect the 'i' input to the value represented by your second lookup table, the 's' input to 'q', and the 'z' output to 'f[1]'. Make sure to connect both instances' 'e' enable pins to a logic high.
- Connect each of the three elements of the 'next_q' bus to the output of a four-input dataflow NAND expression. Each input of the NAND will be one of the elements of the 'p' bus — the inverted product terms generated by the decoder.
- Connect the 'q' bus to right[2:0] for observation.
- Connect the 'next_q' bus to left[2:0] for observation.
- Connect the 'f' bus to right[7:6] for observation.

Your top module should look something like this:
```
module top(...);
    logic [2:0] q;
    logic [2:0] next_q;
    logic [1:0] f;
    always_ff @( ... )
        ...
    logic [7:0] p;
    hc138 decode(.a(q), .e1(0), .e2(0), .e3(1), .y(p));
    hc151 mux1(.i(...), .s(q), .e(1), .z(f[0]));
    hc151 mux2(.i(...), .s(q), .e(1), .z(f[1]));
    assign next_q[0] = ...
    assign next_q[1] = ...
    assign next_q[2] = ...
    assign right[2:0] = ...
    assign left[2:0] = ...
    assign right[7:6] = f;
endmodule
```
**Your next-state function, reset value and lookup table values**

Just as with lab 5, you will implement a unique next-state block, reset value, and output logic for your design. Your next-state table is as follows:



   q   	next_q
0	1
1	4
2	7
3	6
4	3
5	2
6	5
7	0

**Your reset value is 3.**

**Your first lookup table expression is X·Y·Z + X·Y·Z' + X·Y'·Z + X'·Y'·Z + X'·Y'·Z'.**

**Your second lookup table expression is X·Y'·Z' + X'·Y·Z + X'·Y'·Z'.**

Test your system. Ensure that holding down the '1' button immediately forces the 'q' state to the reset value shown above, and the output logic selects the corresponding bits from both the lookup tables. As long as the '1' button is pressed, 'q' should remain set to the reset value regardless of the activity on the clock. When the '1' button is released, each press of the '0' button should immediately cause 'q' to change to 'next_q'. Pressing the '0' button eight times will follow one full cycle of the state back to the starting value.


## Step 1: Implement the next-state equations [6 points]

Normally, you would write next-state logic by creating an always_comb block to hold a case statement that sets up the mapping from inputs to outputs. This prelab is meant to get you ready to understand and wire a circuit that you can test in the real world. Fill in the Verilog dataflow elements for the next_q Let's get started by writing the equations, using Verilog dataflow syntax, for each of your next_q elements, in terms of the p bus elements. For instance, if you wanted set next_q[0] to 1 whenever the q[2:0] is 0, 1, 2, or 3, you would say something like this:

        `assign next_q[0] = ~( p[0] & p[1] & p[2] & p[3] );`

The table you fill out below will enable you to easily wire the circuit.
assign next_q[0] = ~(p[4] & p[6] & p[2] &p[0]);
assign next_q[1] = ~(p[4] & p[3] & p[5] &p[2]);
assign next_q[2] = ~(p[3] & p[6] & p[2] &p[1]);

## Step 2: [14 points]

Create a SystemVerilog file in the simulator, test it well, and upload it here. Include both the top and hc138 module definitions. All of the statements to implement the specified functions should be in the top module.

Are you ready to wire the lab experiment? Make sure you have the chips listed at the top of this prelab assignment. You will need 6 LEDs (of any color you like) to represent the 'q' and 'next_q' buses, and two push buttons serve as the reset and clock controls. When you've tested your circuit, you will plug in the AD2 and use Autolab to evaluate it.
